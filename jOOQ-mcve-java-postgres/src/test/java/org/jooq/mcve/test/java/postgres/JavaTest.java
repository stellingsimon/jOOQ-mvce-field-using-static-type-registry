package org.jooq.mcve.test.java.postgres;

import org.jooq.DSLContext;
import org.jooq.SQLDialect;
import org.jooq.customtypes.MyName;
import org.jooq.impl.DSL;
import org.jooq.mcve.java.postgres.Tables;
import org.jooq.tools.JooqLogger;
import org.junit.*;
import org.junit.rules.ErrorCollector;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.utility.ResourceReaper;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;

import static org.hamcrest.CoreMatchers.*;
import static org.junit.Assert.assertThat;

public class JavaTest {

    static JooqLogger log = JooqLogger.getLogger(JavaTest.class);
    static PostgreSQLContainer<?> db;
    static Connection connection;
    static DSLContext ctx;

    @BeforeClass
    public static void init() throws SQLException {
        if (System.getProperty("jooq.codegen.jdbc.url") == null) {
            db = new org.testcontainers.containers.PostgreSQLContainer<>("postgres:latest")
                    .withUsername("postgres")
                    .withDatabaseName("postgres")
                    .withPassword("postgres")
                    .withInitScript("db/migration/init.sql");

            db.start();
            System.setProperty("jooq.codegen.jdbc.url", db.getJdbcUrl());
            System.setProperty("jooq.codegen.jdbc.username", db.getUsername());
            System.setProperty("jooq.codegen.jdbc.password", db.getPassword());
            System.setProperty("jooq.codegen.jdbc.password", db.getPassword());
        }

        Properties properties = new Properties();
        properties.setProperty("username", "postgres");
        properties.setProperty("password", "postgres");

        log.info("Connecting");
        connection = DriverManager.getConnection(
                System.getProperty("jooq.codegen.jdbc.url"),
                System.getProperty("jooq.codegen.jdbc.username"),
                System.getProperty("jooq.codegen.jdbc.password")
        );

        ctx = DSL.using(connection, SQLDialect.POSTGRES);

        // Use JDBC directly instead of jOOQ to avoid DEBUG logging all of this
        try (Statement s = connection.createStatement()) {
            log.info("Finished setup");
        }
    }

    @AfterClass
    public static void end() {
        if (db != null) {
            ResourceReaper.instance().stopAndRemoveContainer(db.getContainerId(), db.getDockerImageName());
        }
    }

    @Before
    public void setup() throws Exception {
        // disallow static type registry usage:
        System.setProperty("org.jooq.throw-on-discouraged-static-type-registry-access", "true");
    }

    @Rule
    public ErrorCollector collector = new ErrorCollector();

    @Test
    public void mcveTest() {
        Exception exception1 = null;
        try {
            DSL.field("name_field", MyName.class);
        } catch (Exception e) {
            exception1 = e;
        }

        // Now load SOME OTHER class from the JOOQ model via its own static Test.TEST reference.
        // Note that this class itself does not use `MyName` in any way.
        // So naturally, `MyName` still doesn't show up in JOOQ's static type registry
        org.jooq.mcve.java.postgres.tables.Test.TEST.getName();

        Exception exception2 = null;
        try {
            DSL.field("name_field", MyName.class);
        } catch (Exception e) {
            exception2 = e;
        }

        // Now load SOME OTHER class from the JOOQ model via its reference in `Tables`.
        // Note that this class itself does not use `MyName` in any way.
        // But since we loaded `Tables`, we also loaded `Test2` which, as a side effect, puts `MyName` into the static type registry.
        Tables.TEST.getName();

        Exception exception3 = null;
        try {
            DSL.field("name_field", MyName.class);
        } catch (Exception e) {
            exception3 = e;
        }

        final Exception finalException1 = exception1;
        final Exception finalException2 = exception2;
        final Exception finalException3 = exception3;
        assertAll(
                () -> assertThat("exception 1 should be not null", finalException1, is(notNullValue())),
                () -> assertThat("exception 1 should be a DiscouragedStaticTypeRegistryUsage", finalException1.getClass().getCanonicalName(), containsString("DiscouragedStaticTypeRegistryUsage")),
                () -> assertThat("exception 2 should be not null", finalException2, is(notNullValue())),
                () -> assertThat("exception 2 should be a DiscouragedStaticTypeRegistryUsage", finalException2.getClass().getCanonicalName(), containsString("DiscouragedStaticTypeRegistryUsage")),
                () -> assertThat("exception 3 should be not null", finalException3, is(notNullValue())),
                () -> assertThat("exception 3 should be a DiscouragedStaticTypeRegistryUsage", finalException3.getClass().getCanonicalName(), containsString("DiscouragedStaticTypeRegistryUsage"))
        );
    }

    public void assertAll(Runnable... assertions) {
        for (Runnable assertion : assertions) {
            try {
                assertion.run();
            } catch (Throwable t) {
                collector.addError(t);
            }
        }
    }
}
